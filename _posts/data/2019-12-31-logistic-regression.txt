this tutorial is a continuation of the "from scratch" series we started last time with the blog post demonstrating the implementation of a simple k nearest neighbors algorithm. the machine learning model we will be looking at today is logistic regression. if the "regression" part sounds familiar, yes, that is because logistic regression is a close cousin of linear regression both models are employed in the context of regression problems. linear regression is used when the estimation parameter is a continuous variable; logistic regression is best suited to tackle binary classification problems. implementing the logistic regression model is slightly more challenging due to the mathematics involved in gradient descent, but we will make every step explicit throughout the way. without further ado, let's get into it. to understand the clockwork behind logistic regression, it is necessary to understand the logistic function. simply put, the logistic function is a s shaped curve the squishes real values between positive and negative infinity into the range . this property is convenient from a machine learning perspective because it allows us to perform binary classification. binary classification is a type of classification problem where we are assigned the task of categorizing data into two groups. for instance, given the dimensions of a patient's tumor, determine whether the tumor is malignant or benign. another problem might involve classifying emails as either spam or not spam. we can label spam emails as 1 and non spam emails as 0, feed the data into a predefined machine learning algorithm, and generate predictions using that model. if the output of an algorithm given some data point is larger than 0.5, it is likely that the given input is a spam; if it is smaller than the 0.5 threshold, chances are the email is not spam. let's take a look at the shape of the sigmoid function, which is a special case of the logistic function that we will use throughout this post. to plot the sigmoid function, we need to import some libraries. the sigmoid function is defined as follows: we can express this as a python function, as demonstrated in the code snippet below. let's quickly plot the graph to see what the sigmoid function looks like. as we can see, the sigmoid is a smooth, differentiable function that is bounded between 0 and 1. it is also symmetrical around the point , which is why we can use 0.5 as a threshold for determining the class of a given data point. the logistic regression model uses the sigmoid function to generate predictions, but how exactly does it work? recall that, in the case of linear regression, our goal was to determine the coefficients of some linear function, specifically logistic regression is not so different from linear regression. in fact, we can borrow the same notation we used for linear regression to frame logistic regression as follows: in other words, logistic regression can be understood as a process in which our goal is to find the weight coefficients in the equation above the best describe the given data set. unlike in linear regression, where the predicted value is computed simply by passing the data as arguments into a linear function, logistic regression outputs numbers between 0 and 1, making binary classification possible. however, there is certainly an element of linearity involved, which is part of the reason why both linear and logistic regression models fall under a larger family of models called generalized linear models. now that we know the basic maths behind logistic regression using the sigmoid function, it's time to implement it via code. welcome to the next part of the tutorial, where we start building the actual model from scratch. as always, it's a good idea to have some dummy data ready for disposal so that we can develop some basic intuition about dimensionality of our data when handling inputs and outputs of our functions. here is the data we used in the last post on k nearest neighbors algorithm, slightly modified for the purposes of this post. let's start by translating equation into executable code. the idea is that we want to get a dot product of the weight vector and the data vector, then plug the resulting value into the sigmoid function to get some value between 0 and 1. the function shown below exactly performs this task, with the added caveat that it returns a label prediction when the boolean argument is set to ; a raw sigmoid output when the same is set to . let's perform a quick sanity check by using some dummy weight vector. using the coefficients in the list, we can generate predictions for each observation in the . 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 the actual class information is stored in the list. 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 the dummy coefficients are poorly optimized, which is why the predicted class labels do not align well with the actual class labels. this tells us that more tuning is required to update the coefficients and build a robust logistic regression model. but how exactly can we tune our model? simply eyeballing the actual and predicted labels of our data is probably not going to help us much. to optimize the coefficients to best fit our data, we need to construct some loss function that is, a function that describes how badly our model is performing. then, we can optimize the weights of our model by minimizing that loss function, which would mean that our model gradually makes better predictions with each round of optimization. if you recall the previous post on entropy, you will remember that we discussed a concept called cross entropy. in that post, we derived the formula for cross entropy and intuitively understood it as a way of measuring the "distance" between two distributions. this is exactly what we need: a way of quantifying how different the actual and predicted class labels are! recall the formula for cross entropy: we can consider class labels as a bernoulli distribution where data that belongs to class 1 has probability 1 of belonging to that class 1 and probability 0 of belonging to class 0, and vice versa for observations in class 0. the logistic regression model will output a bernoulli distribution, such as , which means that the given input has a 60 percent chance of belonging to class 1; 40 percent to class 0. applying this to , we get: and that is the loss function we will use for logistic regression! the reason why we have two terms, one involving just and another involving is due to the structure of the bernoulli distribution, which by definition can be written as now that we have a loss function to work with, let's build a function that computes cross entropy loss given and using . the function returns the average cross entropy over all input data. we use average cross entropy instead of total cross entropy, because it doesn't make sense to penalize the model for high cross entropy when the input data set was large to begin with. now what's next? since we have a loss function, we need to build an algorithm that will allow us to minimize this cost function. one of the most common methods used to achieve cost minimization is gradient descent. as you might be able to tell, this algorithm has a lot to do with gradients, which can loosely be understood as a fancy way of saying derivatives. below is an illustration of the gradient descent algorithm in action, sourced from this blog. basically, what gradient descent does is that it takes the derivative of the loss function with respect to the weight vector every epoch, or iteration, and takes a small step in the opposite direction of that derivative. if you think of this in the context of two dimensions as shown in the illustration, the gradient descent algorithm ends up moving down the parabola, taking little steps each time, until it eventually reaches the global minimum. in mathematical notation, we might express this process as follows: if we were to perform this in vectorized format, where represents a vector containing the weight coefficients of the logistic regression model: the notation is used to denote gradients, an important operation in matrix calculus which we explored in when deriving the normal equation solution to linear regression on this blog. the denotes a hyperparameter known as the learning rate, which essentially determines how big of a step the gradient descent model takes with each iteration. the main takeaway here is the the gradient descent method allows us to find the local minimum of any convex function, no matter how multidimensional or complex. this is an incredibly powerful statement, and it is one that lies at the core of many machine learning algorithms. to implement gradient descent with code, we have to figure out what the gradient descent equation is in the case of logistic regression. to do this, we need a bit of calculus work using the chain rule. recall that our goal is to compute since we want to calculate the slope of the cross entropy function with respect to the weights vector. for notational convenience, let's denote the gradient as a derivative: the gradient in can be broken down into distinct components via the chain rule: where so the task of calculating the gradient now boils down to finding the derivative for each of the terms shown in . let's start with the easiet one, the last term, which is the derivative of with respect to . from , we can conclude that the next in line is the derivative of the sigmoid function, which goes as follows: now we are almost there. the last piece of the puzzle is computing the first term in , the derivative of the cross entropy function. putting this all together into , we get: voila! we have derived an expression for the gradient of the cross entropy loss function. there is one more tiny little step we have to make to concretize this equation, and that is to consider the average of the total gradient, since as it stands applies to only one data observation. granted, this derivation is not meant to be a rigorous demonstration of mathematical proof, because we glossed over some details concerning matrix transpose, dot products, and dimensionality. still, it provides a solid basis for the construction of the gradient descent algorithm in code, as shown below. to avoid compensating code readability, i made a stylistic choice of using and to denote the vector of coefficients instead of using for notational consistency. other than adding some switch optional parameters such as or , the code simply follows the gradient descent algorithm outlined above. note that equation is expressed via ; equation is expressed by the line . let's quickly check that the function works as expected using the dummy data we created earlier. iteration 0, cost: 1.182528373826317 iteration 50, cost: 0.1306481850308255 iteration 100, cost: 0.07491036607639494 iteration 150, cost: 0.053585058580496114 array great! we see that the average cross entropy decreases with more iterations. the returned array contains the coefficients of the logistic regression model, which we can use to now make predictions. we can stop here, but just like we did in the post on k nearest neighbors, let's wrap all the functions we have created so far into a single function that represents the logistic regression model. our model is ready. time for testing with some real world data. let's import some data from the web. the data we will be looking at is the banknote authentification data set, publicly available on the uci machine learning repository. this data set contains 1372 observations of bank notes, classified as either authentic or counterfeit. the five features columns of this data set are: variance of wavelet wavelet transformed image skewness of wavelet transformed image kurtosis of wavelet transformed image entropy of image class let's use some modules to import this data set onto our notebook, as shown below. the imported data set was slightly modified in two ways to fit our model. first, i separated the class label data from the data set and stored it as a separate array. second, i appended s to each observation to create a new column that accounts for intercept approximation. all this means is that we consider our linear model to be where for all available sample observations. this is something that we have been assuming all along throughout the gradient descent derivation process, but had not been stated explicitly to reduce confusion. just consider it a strategic choice on our part to simplify the model while allowing for the logistic regression model to consider bias. let's check the shape of the imported data set to check that the data has been partitioned correctly. now, it's time to split the data into training and testing data. to do this, i recycled a function we built earlier in the previous post on k nearest neighbors algorithm. using , we can partition the data set into training and testing data. let's make 20 percent of observations as testing data and allocate the rest for training. it's time for some training and prediction generation. because we did all the work in the previous section, training and predicting can be achieved with just a single line of command. to see how quickly average cross entropy is decreasing, i turned on the as true. this way, we can see how quickly the loss is declining over every 50 epochs. iteration 0, cost: 1.8645873915204194 iteration 50, cost: 0.12724295853835318 iteration 100, cost: 0.09500780070378237 iteration 150, cost: 0.08051200520236851 iteration 200, cost: 0.07152813537793914 iteration 250, cost: 0.06521190357551303 iteration 300, cost: 0.06046029372003293 iteration 350, cost: 0.0567287055259228 iteration 400, cost: 0.05370806680847458 iteration 450, cost: 0.05120649109874576 iteration 500, cost: 0.04909714872119953 iteration 550, cost: 0.047292239538382304 iteration 600, cost: 0.045728769034644075 iteration 650, cost: 0.04436022796651144 iteration 700, cost: 0.04315146064694956 iteration 750, cost: 0.042075362704003874 iteration 800, cost: 0.041110680842644444 iteration 850, cost: 0.04024050353492443 iteration 900, cost: 0.0394511996919855 iteration 950, cost: 0.038731656216495214 it's now time to see how well our model has done. let's compare , the list that contains the model's predictions, with , which is essentially the answer key. {true: 272, false: 2} this is great news. the result shows us that we have correctly predicted 272 values while making wrong predictions in only 2 cases. let's systematize this quantity by creating a function that returns how accurate our model is given and . let's use this function to test how well our model performed. 0.9927007299270073 99 percent is not a bad estimate at all. one interesting question to consider is how much boost in accuracy we see with each epoch, i.e. what is the bang per buck of each iteration cycle? this is an important question to consider because gradient descent is computationally expensive; if we can train our model in just 10 epochs instead of 1000, why not choose the former? to answer this question, let's plot accuracy against epoch. for fun, i added the learning parameter as an argument to the function as well. let's create a plot to see how accuracy changes over 200 epochs, given a learning rate of 0.1. we see that accuracy spikes up on the first 20 epochs or so and quite quickly converges to about 90 percent. past a certain threshold, the model seems to hover consistently at around the high 90s range, but accuracy still continues to increase ever so slightly with each epoch, though not as quickly as before. if we set the learning rate to a smaller number, we would expect the model to take a lot longer to tune, and indeed this seems to be true: with a much smaller learning rate, the model seems to struggle to achieve high accuracy. however, although there are a lot of uneven spikes, the model still manages to reach a pretty high accuracy score by 200 epochs. this tells us that the success of model training depends a lot on how we set the learning rate; setting an excessively high value for the learning rate might result in overshooting, while a low learning rate might prevent the model from quickly learning from the data and making meaningful progress. accuracy helps us intuitively understand how well our model is doing, but recall that the main objective of gradient descent is not to maximize accuracy, but to minimize the cross entropy loss function. therefore, perhaps it makes more sense to evaluate the performance of our logistic regression model by plotting cross entropy. presented below is a simple function that plots epoch versus cross entropy given a list of learning rates, . let's plot cross entropy loss for three different values of : 0.05, 0.1, and 0.5. just like before, we cap the number of iterations to 200 epochs. the graph shows that the larger the learning rate, the quicker the decrease in cross entropy loss. this result is coherent with what the previous visualizations on accuracy suggested: the higher the learning rate, the quicker the model learns from the training data. in this post, we built the logistic regression model from scratch by deriving an equation for gradient descent on cross entropy given a sigmoid function. in the process, we brought together many useful concepts we explored on this blog previously, such as matrix calculus, cross entropy, and more. it's always exciting to see when seemingly unrelated concepts come together to form beautiful pictures in unexpected ways, and that is what motivates me to continue my journey down this road. the logistic regression model is simple yet incredibly powerful in the context of binary classification. as we saw earlier with the application of the model to the task of bank notes authentication, the logistic regression model can, when tweaked with the appropriate parameters, make surprisingly accurate predictions given sufficient amount of training data. of course, the processing of training and tweaking is not always easy because we have to determine some hyperparameters, most notably the learning rate of the gradient descent algorithm, but the fact that logistic regression is a robust model is unchanged nonetheless. hopefully this post gave you some idea of what happens behind the scene in a regression based machine learning model. thanks for reading. see you in the next post, and happy new year! this blog: https://scipython.com/blog/visualizing the gradient descent method/ the blog post: https://jaketae.github.io/study/knn/ logistic function: https://en.wikipedia.org/wiki/logistic_function linear regression: https://jaketae.github.io/study/linear regression/ binary classification: https://en.wikipedia.org/wiki/binary_classification generalized linear models: https://en.wikipedia.org/wiki/generalized_linear_model previous post: https://jaketae.github.io/study/information entropy/ cross entropy: https://en.wikipedia.org/wiki/cross_entropy uci machine learning repository: https://archive.ics.uci.edu/ml/datasets/banknote+authentication gradient descent: https://en.wikipedia.org/wiki/gradient_descent
principal component analysis is one of those techniques that i've always heard about somewhere, but didn't have a chance to really dive into. pca would come up in papers on gans, tutorials on unsupervised machine learning, and of course, math textbooks, whether it be on statistics or linear algebra. i decided that it's about time that i devote a post to this topic, especially since i promised one after writing about singular value decomposition on this blog some time ago. so here it goes. what do we need principal component analysis for? or more importantly, what is a principal component to begin with? well, to cut to the chase, pca is a way of implementing dimensionality reduction, often referred to as lossy compression. this simply means that we want to transform some data living in high dimensional space into lower dimensions. imagine having a data with hundreds of thousands of feature columns. it would take a lot of computing power to apply a machine learning model to fit the data and generate predictions. this is when pca comes in: with pca, we can figure out which dimensions are the most important and apply a transformation to compress that data into lower dimensions, making it a lot more tractable and easier to work with. and in case you're still wondering, principal components refer to those new extracted dimensions used to newly represent data! let's derive pca with some good old linear algebra tricks. i used ian goodfellow's deep learning and a lecture slide from columbia references for this post. the setup of a classic pca problem might be summarized as follows. suppose we have a dataset of points, each living in dimensional space. in other words, where our goal is to find a way to compress the data into lower dimensional space where . we might imagine this as a transformation, i.e. the objective is to find a transformation so that applying will yield a new vector living in lower dimensional space. we can also imagine there being a reverse transformation or a decoding function that achieves because pca is in essence a linear transformation, it is most natural to express and understand it as a matrix. let's define this transformation as , and the matrix corresponding to the decoding . in other words, pca makes a number of assumptions to simplify this problem. the most important assumption is that each column of is orthogonal to each other. as we will see later in an alternate derivation with statistics, this has to do with the notion of covariance. another restriction is that the columns of must have a euclidean norm of one. this constraint is necessary for us to find a unique matrix that achieves compression otherwise, we could have any multiples, leading to an infinite number of such matrices. we make one more convenient assumption about the given data points, . that is, is assumed to have a mean of zero, i.e. . if this is not the case, we can easily perform standardization by subtracting the mean from the data. with this setup in mind, let's finally start the derivation. as said earlier, the goal of pca is to compress data with as little loss of information as possible. we don't want to compress data in a haphazard fashion; instead, we want the compression scheme to be able to preserve the structure of the data as much as possible in its lower dimensional representation. from this, we can come up with the following equation: in other words, the goal is to find that which minimizes the difference between the original data and the reconstructed data. note that finding this optimal amounts to finding that most effectively compresses given data. instead of the l2 norm, let's consider the squared l2 norm for convenience purposes. note that minimizing the l2 norm is equal to minimizing the squared l2 norm, so there is no semantic difference. by definition of vector transpose, we can now express the squared l2 norm versions of as follows: where the second to last equality is due to the fact that and are both constants that denote the same value. also, the argument of the minimum is with respect to , we can omit the first term, which is purely in terms of . it's time to take derivatives. but in order to do so, we need to unpack , since we have no idea how to take its derivative. using , we can reorganize as follows: the last equality is due to the fact that we constrained the columns of to be unit vectors that are orthogonal to each other. now we can take a derivative of the argument with respect to and set it equal to zero to find the minimum. this tells us that the optimal way of compressing is simply by multiplying it by the transpose of the decoding matrix. in other words, we have found the transformation in . for those of you who are confused about how gradients and matrix calculus work, here is a very short explanation. first, notice that is just a scalar, since is a column vector. taking a gradient with respect to this quantity would mean that we get another column vector of equal dimensions with with the following elements: and we know how to go from there. the same line of thinking can be applied to think about the second term, . we know that is a row vector since its dot product with should be possible dimensionally speaking. then, we know that the gradient with respect to should give each of the elements of , but in column vector format hence the need for a transpose. in general, the rule of thumb is that the gradient of a scalar with respect to a vector or a matrix should return a vector or matrix of the same dimension. recall from that reconstruction can be achieved by applying compression followed by a decoding operation: since we know that is just and is by definition, we can express in a different way. in retrospect, this is somewhat intuitive since can roughly be thought of as a pseudo orthonormal matrix pseudo since there is no guarantee that it is a square matrix. now, all that is left is to find the matrix . the way to go about this is to reconsider , the notion of minimizing data loss, given our findings in . in other words, instead of considering a single observation, here we consider the design matrix in its entirety. note that is a design matrix whose rows correspond to a single observation. and because we are dealing with matrices, the euclidean norm was replaced with its matrix equivalent, the frobenius norm. observe that the first term can safely be removed from the argument since it is a constant with respect to ; let's also change the argument of the minimum to the maximum given the negative sign. the frobenius norm of a real matrix can be calculated as therefore, the last equality is due to a useful property of trace, which is that we can cycle the order of matrices without changing its value. let's consider a single column in , denoted as . you might also imagine this as a situation where is one dimensional, meaning we want to compress data into a single scalar value. it is not difficult to see that the trace of , which is a scalar in the one dimensional case, is maximized when is an eigenvector of with the largest eigenvalue. generalizing this result back to , we see that is a matrix whose columns correspond to the eigenvectors of in descending order. if you had prior exposure to pca, you might know that the standard way of obtaining principal components is by calculating the covariance matrix of the data and finding its eigenvectors. here, i attempt to present an explanation of how and why the procedure outlined in the preceding section is essentially achieving the same tasks, albeit through a different frame of thought. the unbiased sample covariance matrix is given by of course, this is operating under the assumption that has already been standardized such that the mean of the data is zero. and certainly look different. however, under the hood, they express the same quantity. in , we assumed from the beginning that our data has a mean of zero. in , we make this assumption explicit by subtracting the mean from the data. in , we assumed a row based design matrix, where each data point is stored as a row vector. in , we assumed that each data points are stored as columns of the design matrix; hence the difference in the order of transpose. in , we are dealing with the unbiased sample covariance matrix, which is why we divide by a fraction of . in , we simply express this division as an expectation encapsulating the entire expression. so in a nutshell, the conclusion we arrived at in the preceding section with the minimization of residual sums ultimately amounts to finding the covariance matrix and its eigenvectors. i found this to be the more dominant interpretation of pca, since indeed it is highly intuitive: the goal of pca is to find the axes or the principal components that which maximize the variance seen in the data. setosa.io has some excellent visualizations on the notion of covariance and how it relates to pca, so i highly recommend that you go check it out. if were to derive pca from the gecko with the covariance approach, we would be using an iterative approach to find a single principal component at a time. specifically, our goal would be to find that which maximizes hence the problem is now framed as a constrained optimization problem. we use lagrangians to solve constrained optimization. the intuition for the lagrangian method is that the gradient of the constraint and the argument should be parallel to each other at the point of optimization. we go about this by taking the gradient of the argument with respect to : since 2 is just a constant, we can absorb it into to form a more concise expression. also, since the covariance matrix is by definition symmetric, we can simplify things further to end up with and once again, we have shown that the principal components are the eigenvectors of the covariance matrix. but the procedure outlined above can be used to find only one principal component, that is the eigenvector with the largest eigenvalue. how do we go about searching for multiple eigenvectors? this can be done, once again, with lagrangians, with the added caveat that we will have more trailing terms in the end. let's elaborate on this point further. here, we assume that we have already obtained the first component, , and our goal is to find the next component, . with induction, we can easily see how this analysis would apply to finding . simply put, the goal is to maximize under the constraint that is orthogonal to while also satisfying the constraint that it is a unit vector. therefore, using lagrangians, in the last equality, we make a trivial substitution to simplify and get rid of the constant. we also use the fact that the covariance matrix is symmetric. if we left multiply by , but since , the first two terms go to zero. also, the last term reduces to since . this necessarily means that . if we plug this result back into , we end up with the definition of the eigenvector again, but this time for . essentially, we iterate this process to find a specified number of principal components, which amounts to finding number of eigenvectors of the sample covariance matrix. a while back, we discussed both eigendecomposition as well as singular value decomposition, both of which are useful ways of decomposing matrices into discrete factors. in this section, we will see how pca is essentially a way of performing and applying these decomposition techniques under the hood. recall that eigendecomposition is a method of decomposing matrices as follows: where is a diagonal matrix of eigenvalues and is a matrix of eigenvectors. pca is closely related to eigendecomposition, and this should come as no surprise. essentially, by finding the eigenvalues and eigenvectors of , we are performing an eigendecomposition on the covariance matrix: notice that is a matrix of principal components. of course, in this case, is a square matrix of full rank; to apply dimension compression, we need to slice the first entries of . at any rate, it is clear that pca involves eigendecomposition of the covariance matrix. eigendecomposition can only be applied to matrices of full rank. however, there is a more generalized method for non square matrices, which is singular value decomposition. here is a blueprint of svd: where is a matrix containing the roots of the eigenvalues, with appropriate dimensional configurations to accommodate the shape of the original matrix. we cannot perform eigendecomposition on , which has no guarantee that it is square; however, svd is definitely an option. assume that can be decomposed into , , and . then the covariance matrix becomes and we end up in the same place as we did in . this is no surprise given that the derivation of svd involves eigendecomposition. in this post, we took a deep dive into the mathematics behind principal component analysis. pca is a very useful technique used in many areas of machine learning. one of the most common applications is to apply pca to a high dimensional dataset before applying a clustering algorithm. this makes it easier for the ml model to cluster data, since the data is now aligned in such a way that it shows the most variance. upon some more research, i also found an interesting paper that shows that there is a solid mathematical relationship between k means clustering and pca. i haven't read the paper from top to bottom, but instead glossed over a summary of the paper on this thread on stack overflow. it's certainly a lot of information to take in, and i have no intent of covering this topic in this already rather lengthy post on pca. so perhaps this discussion will be tabled for a later time, as interesting as it seems. i hope you enjoyed reading this post. amidst the chaos of the covid19 pandemic, let's try to stay strong and find peace ruminating over some matrices and formulas. trust me, it works better than you might think.
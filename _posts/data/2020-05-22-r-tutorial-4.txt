in this post, we will continue our journey down the r road to take a deeper dive into data frames. r is great for data analysis and wranging when it comes to dealing with tabular data, especially thanks to the package, which is r’s equivalent of python’s . setup ===== let’s begin by loading . library we will also be using the package, which is a dataset documenting all flights departing new york city in 2013. library lets take a look at what this dataset looks like. head on a quick side note, i’ve recently realized that we can also use the pipe operator from . this is somewhat similar to how pipes work in unix. for example, instead of , we can also do flights %% head i’ve found that some people refer to use this pipe operator when dealing with , because doing so arguably improves code readability by separating out the dataset from the rest of the arguments of the function. with this note in mind, let’s jump into . basic operations ================ in this section, we will take a look at some basic operations we can perform on data frames, namely , , , , and . if you are familar with sql or , the semantics of some of this words might come a bit more naturally. but even if they don’t, worry not; we will go through each function one by one and get our hands dirty. filter as the name implies, literally filters the data frame according to some condition. this is similar to how filter works in other languages. let’s take a look at a python example. to run python code in r notebooks , we can import the package. library nums = list) odd_nums = list) odd_nums here, we have filtered the list according to the simple function defined in line. this is essentially how works in as well. let’s take a look at an example. say we want to only look at flights scheduled on january 1st. then, we can do flights %% filter %% head in a simple example like this, using pipe operators may not be necessary, but one advatnage is that we can avoid the use of nested functions. we can also avoid the use of creating intermediary local variables. let’s continue our discussion of the function. we can exploit the full powers of by using it in conjunction with various logical operators. for example, if we want to retrieve the list of flights that occurred in either january or feburary, we can do flights %% filter the translates to “or.” we also have things like , with stands for “and,” , which stands for “not,” and , which stands for the exclusive or. one refinement we can add to the statement above is the use of . flights %% filter) to check for ranges, we can use the function. for example, flights %% filter) %% head here, we only filter those flights whose departing time was between 6 and 7 in the morning. as one last example, let’s filter through the data frame and try to see which entries have missing values for . to do this, we can use . flights %% filter) %% nrow we see that there are a total of 8255 rows whose column is missing. select is another very useful function for retrieving information from a data frame. if a voice in your head starts whispering sql, well, that’s sort of the right idea. the function, as you might expect, literally selects columns from a data frame, much like the statement in sql does the same. of course, we can also add conditions for selection, similar to how works in sql. let’s get more concrete by taking a look at an example. flights %% select %% head here, we have selected three columns, , , and , from the data frame. we can also make use of slicing for selection, using the and the syntax. flights %% select) %% head here, we have selected every column except the ones between to , inclusive. the power of truly comes into light when we use in conjunction with other helper functions, such as , , or . this is somewhat similar to what sql offers with the keyword. for example, select col_a, col_b from some_table where col_c like 'a%' would give us data points from where the entry starts with the character . this directly corresponds to the helper function. mutate, transmute another useful function to have under our belt is the ability to create new columns using existing columns in the data frame. for example, we might want to calculate a new variable, , as follows: speed = distance / air_time 60 an easy way to achieve this is to use . let’s see this in action. flights %% mutate %% select %% head here, we first created a new column, named , using the formula delineated above, then selected that specific column and displayed the first five entries. note that is not an in place operation. instead, it creates a copy. therefore, in order to save the results, we must store it to a new data frame object. new_flight % mutate head what if we want to get only the newly created column, instead of appending it to the entire copy of the data frame? in other words, is there a more elegant way of doing things instead of applying after as we have done in the example above? well, this is exactly what is for. flights %% transmute %% head this gives us the same result as applying a after , and indeed it is much more concise and readable. while does not really add expressive power, it is a convenient function to have nonetheless. arrange in sql speak, is r’s way of ordering entries in ascending or descending order. in , we can achieve the same result using . let’s take a look. flights %% arrange %% head because we arranged, or sorted, the data frame in the order of , , and , the first entries we get are from january 1st of 2013. note that by default, sorts entries in ascending order. to do things in descending order, we need to wrap column variables around , as in , for instance. summarize is a very useful function that collapses contents on the data frame into a single row. quite aptly, it provides a nice way to summarize the data. for example, if we are interested the mean of the column, we might do flights %% summarize) here, we have calculated the mean of and labeled it as . we toggle since does contain null entries. aside from there are several functions can come in handy. here is a non exhaustive list: : mean absolute deviation for example, let’s see how works. flights %% count %% head this is functionally equivalent to flights %% group_by %% summarize) %% head this provides a nice segue into , which we have just seen in the example above. group by is useful, but it is pretty boring when used alone. instead, we might want to use it in conjunction with , which is another very powerful function in . if you come from a or sql background, you might already be familiar with what does: as the name implies, the operation groups the data frame according to some axis or column dimension. this is useful because now we can apply operations like calculating the mean on these groups individuall, then get an aggregated result. for instance, delay_by_month % group_by %% summarize) delay_by_month now we get a nice summary of the data set, namely the mean delay time for flights each month. here, we might proceed with some visualization. here is a quick review. ggplot + geom_bar, stat = "identity") it seems like the most delays happen in the summer and the winter. we can’t be sure with just this data, and we certainly shouldn’t be jumping to any conclusions, but one plausible hypothesis might be that people tend to go on vacation trips during these months, possibly leading to more delays as more flights are in operation. one useful note to mention is the fact that grouping by multiple variables, then applying a summary effectively peals off one layer of the axis by which the data frame is grouped. this is a mouthful, but let’s see what this means with an example. per_day % group_by %% summarize) head if we apply another summary on this data frame, we obtain per_month % summarize) head notice that the column is now gone, and instead we have a data frame grouped by and only. then, it won’t come as a surprise that re applying this step once more would result in : per_year % summarize) head in this case, the result is uninteresting because the dataset only pertained to flights that occurred in 2013 to begin with. but if we had more than one year, then we would expect the results to have shown up here. is not the only function that works well with . in fact, we can use it on any function we have learned so far. for example, here is an example with . flights %% group_by %% filter 200) this returns a data frame containing entries for only popular destinations. here is another example, this time in combination with , , and . flights %% filter %% mutate) %% select %% head as can be witnessed in these examples, offers a powerful way of organizing data, especially when combined with different operators. pipeline workflow ================= let’s take a look at an example from r4ds, which is the task of exploring the relationship between distance and the average delay for each flight destination. here is one way we might go about it using the pipeline operator and the functions we have learned so far. dist_delay % group_by %% summarize, mean_dist = mean, mean_delay = mean ) %% filter head now that we have the data ready, let’s try plotting it. ggplot) + geom_point, alpha = 1/3) + geom_smooth we’ve grouped the data set according to , then applied some summarize function to aggregate the data by mean, then filtered the results so that we only have destinations that had more than 20 flights in 2013.note that we chucked in a function we haven’t seen before, , which basically returns the number of rows in a data frame. because we applied a , the would give us the number of counts of entries for each destination. the aspect of the workflow should be familiar from the previous tutorial. we can also use in conjunction with by using pipe. for example, say we want to drill down on flight delay times. first, let’s begin by filtering entries with missing values. delays % filter, !is.na) %% group_by %% summarize, delay = mean ) head using this data frame, we can create a plot as follows: ggplot) + geom_point let’s get rid of some outliers with only a few counts, as they skew the y axis. delays %% filter %% ggplot) + geom_point see how we were able to use data frame manipulation with directly: we were able to elide the argument because the resulting data frame was directly piped into the function. conclusion ========== r4ds chapter 3 contained a lot of dense information, but the basics of using pipelines, selecting, mutating, fitering, and group by’s on data frames are no doubt useful skills that will come in handy in future tutorials. i personally don’t think it is necessary to digest everything that is in the book nor what is written here: instead, it’s important to see the philosopy of r and . it’s always fun to learn new syntax of a language, and i think that’s part of the reason why i’ve enjoyed writing this post despite the density of the material presented. i hope you enjoyed reading this post. in the next post, we’ll probably discuss the how to’s of exploratory data analysis, thus putting our skills to the test. see you in the next one!
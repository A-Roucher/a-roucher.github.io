in this post, we will be taking a look at a very simple yet popular search algorithm, namely breadth first search and depth first search methods. to give you some context, i've been solving some simple algorithms problems these days in my free time. i found that thees puzzles are very brain stimulating, not to mention the satisfying sense of reward when my code works. bfs and dfs search methods are widely applicable coding problems, so i decided to write a short post on this topic. on a separate note, i'm writing this notebook in jupyter labs instead of jupyter notebooks. jupyter labs feels very similar to the former, but the interface is arguably more modern looking. i'm not sure how i feel jupyter labs yet, but hopefully as i get to discover more features on this platform, i'll get a better idea of which interface better suits my workflow. let's get started! bfs and dfs are graph search methods. this means that we will need to have a way of representing a graph with code. of course, the most intuitive way of representing a graph would be to draw it; however, this would be meaningless to a computer. instead, we will use what is called an adjacency list, which is basically some data structure, mostly a hash map, whose key represents a node and values, the number of connected vertices on the graph. this is one way we can represent information on the vertices and edges of a graph. this example was borrowed from itholic's blog. here is an accompanying image to go along with the hash map. note that our mode of representation can only express unweighted directed or undirected graphs that is, the edges between each edges are weightless. to express weighted graphs, we can use something like symmetric matrices, also known as adjacency matrices, that contain information on the distance between each node. given an adjacency matrix , we would denote the distance between nodes and via . graph representation is an interesting topic, but it is beyond the scope of this post. for now, let's stick with the dictionary representation as shown above and continue probing the world of bfs and dfs. as the name implies, the bfs algorithm is a breadth based approach. what this means is that we explore each possibility layer by layer: when traversing the graph, we look at the entire picture hence the breadth then move onto the next step. here is a crude analogy for visual thinkers: imagine you have a frappuccino. if bfs were a person, they would drink the first layer the whipping cream, for instance then move onto the next. in contrast, mr. dfs would stick a straw into the cup and drink a little bit of each layer before moving the straw to some other location within the cup and taking a sip again. dfs goes deep, whereas bfs goes wide. enough of the coffee analogy, let's see how we can use bfs to traverse the graph. and here is the result we get when we perform a bfs on the graph. the returned list shows the order in which the nodes in the graph were visited. 'a', 'b', 'c', 'h', 'd', 'i', 'j', 'm', 'e', 'g', 'k', 'f', 'l' if you look at the visual illustration of the graph above and follow the path that was returned by the function call, you will quickly see that the order in which the nodes were visited can be understood as level traversal. recall the frappuccino analogy, where we said that mr. bfs would drink the coffee layer by layer. the result aligns with our earlier characterization and analogy. while there is nothing wrong with the function as it is, we can perform some slight optimization by using . notice that in the original function, we used to obtain the first element in the queue. this is a costly operation that takes time due to the nature of array data structures. the operation itself, which pops the last element of the list, takes only time complexity, but popping the first element or the head of the list takes linear time. we can thus use 's built in to micro optimize the algorithm. there is no change in the output path, since the underlying logic remains unchanged. 'a', 'b', 'c', 'h', 'd', 'i', 'j', 'm', 'e', 'g', 'k', 'f', 'l' now let's turn out attention to dfs. as you might be able to tell from the name, dfs first goes deep into the graph until it reaches a leaf node. then, it traverses the graph back up to its root, then taking another node to deeply search again. if you look at the function, you will notice that nothing much has changed from the earlier function. in fact, the only difference is that we now perform a normal on the list, thus obtaining its last element, instead of doing something like or as we had done above. while this may seem like a very minor difference, the implications of this design choice is substantial: dfs traverses the graph very differently from bfs. the key difference is that dfs goes down the graph, then comes back up, repeating this up and down motion until all nodes are visited. this vertical movement can also be understood, from a level's perspective, as depth hence the name, dfs. 'a', 'b', 'h', 'm', 'j', 'k', 'l', 'i', 'c', 'd', 'g', 'e', 'f' the implementation of the dfs traversing algorithm above used iteration with a loop. however, we can also use recursion with an inner helper function to populate the results list, then return the populated result. this uses the convenient fact that we can have nested functions in python with an internal local variable whose scope is effectively global for the inner function. if you think about the order in which the recursive calls are being made in the function, it will become obvious that the we had in the iterative version of the dfs algorithm was basically simulating an actual stack frame on the computer with recursion. in other words, the two methods achieve the same functionality, albeit in seemingly different ways. 'a', 'b', 'h', 'm', 'j', 'k', 'l', 'i', 'c', 'd', 'g', 'e', 'f' an interesting application of the dfs and bfs algorithms is in the context of path finding. in the examples above, we simply traversed the entire graph in order determined by the algorithm, given a starting node. however, what if we want to find ways to get from node x to node y? the traversing algorithm does not answer this question directly. so let's use these algorithms to answer the question in a more direct manner. note that finding the longest or shortest path from one node to another is considered an np hard problem, which means that it is a very difficult problem to which computer scientists and mathematicians have yet to find an answer for. the dfs or bfs approach outlined below is a very crude way of going about this problem and can hardly be called as a solution given the exponential amount of computation that is needed to perform on much complicated graphs. with this bearing in mind, let's take a look. in the example below, we use dfs to find one possible path from to . note that this may not be the quickest path, since dfs is unable to look at the graph level by level for that, we will need bfs. check that the function works as expected. 'a', 'b', 'h', 'j', 'k', 'l' next, here is the same path finding algorithm using bfs. the code is nearly identical to the dfs model we've seen above, but because this algorithm uses level order traversal, we can say with more confidence that the returned result is the shortest path from to . we also apply the micro optimization method we reviewed earlier with . because we had a very simple example, it turns out that the method we found with dfs was in fact the shortest path. 'a', 'b', 'h', 'j', 'k', 'l' the methods above return an efficient path from to . but what if we want to know all possible paths that are possible, even if some of them might be elongated or inefficient? the idea is that we specify a set number of iterations we want the algorithm to run for, denoted in the function parameter as . during that , we find all paths that are possible. when the iterations are over, we return the result. let's try running this for a hundred iterations and see what we get. 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'c', 'b', 'h', 'j', 'k', 'l' great! note that the path we get all starts with and ends with , which is what we had specified. one problem, however, is the fact that besides the first path, the second and third paths include somewhat ineffective paths, where the walker presumably goes from to , then back to , and so on. this problem becomes even more apparent when we run it for more iterations. 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'c', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'h', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'h', 'i', 'h', 'j', 'k', 'l', 'a', 'b', 'h', 'j', 'h', 'j', 'k', 'l', 'a', 'b', 'h', 'j', 'k', 'j', 'k', 'l', 'a', 'b', 'h', 'm', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'c', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'i', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'j', 'h', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'j', 'k', 'j', 'k', 'l', 'a', 'b', 'a', 'b', 'h', 'm', 'h', 'j', 'k', 'l', 'a', 'b', 'c', 'b', 'a', 'b', 'h', 'j', 'k', 'l', 'a', 'b', 'c', 'b', 'c', 'b', 'h', 'j', 'k', 'l' if we want to obtain only those results that are non overlapping, we can add a manual check, i.e. add only those results that have unique nodes. we add this check by adding a control statement, namely . this ensures that the node that we are considering is not a node that the path had already visited before. and if we run this on the graph, we obtain the result that we had expected. 'a', 'b', 'h', 'j', 'k', 'l' however, this is a rather boring example. let's alter the graph a bit by adding a bidirectional connection between nodes and . notice that this creates an internal loop within the graph. in graph theory language, this is known as a strongly connected component, and we might explore this topic in a future post. for now, we can understand them as a loop, the implication of which is that there are now multiple ways to get from one node to another via that loop. this time, when we run the path finding algorithm, we find that there are two ways of going from node to node . 'a', 'b', 'h', 'i', 'a', 'b', 'c', 'd', 'g', 'i' in this last section, we will take a look at two leetcode bfs related problems. one thing that i have slowly realized is that, solving a coding puzzle does not mean that i have understood the problem. in fact, more often or not, i've found myself struggling to solve problems that i somehow managed to solve weeks or months ago. i've therefore decided that it is good practice to come back to previous problems once in a while for review. the first problem is problem 102. this involves level order traversal of a binary search tree. upon reading this question, a small voice in you should be yelling "bfs, bfs!", because we have repeated many times that bfs is reminiscent of level order traversal, where we search a tree or a graph layer by layer. here is my solution. the idea is pretty simple: in , we keep track of nodes to visit. these nodes obviously live in the same level. then, we loop through this list of nodes. if the node is not , we add its value to a temporary list within the loop, denoted as . when we are done traversing the nodes in that level, we append the accumulated results of to . we also keep track of the next layer via . this contains the nodes to visit in the next iteration, so it becomes the new . in the next iteration, we repeat what we have done on the list until there is no more nodes to traverse, i.e. we are at the leaf nodes. this is problem 101 on leetcode. the problem is simple: we want to check if a binary tree is symmetric. an example of a symmetric tree is visualized below: how might we go about this? my initial thought was that we could use level order traversal and check if, at each level, the values of the node are symmetric. this check of symmetry can be done simply by doing something like a palindrome check, i.e. . however, upon more research and thinking, i've realized that there are smarter ways to do this by using queues. all we have to do is to make sure that the value of the left and right nodes are identical. if they are, now we need to check if the value of the left child of the left node is equal to that of the right child of the right node. this is the outer layer comparison, represented as . for an inner layer comparison, we need to check if the value of the right child of the left node is equal to that of the left child of the right node. this corresponds to . in the example above, for instance, we need to check that and are equal, and also that and are equal in the outer most leaf nodes. we add these to the queue so that comparisons can be made in the iterations that follow. in this post, we looked at bfs and dfs algorithms. these algorithms are very useful for traversing a tree structure. a generalization of dfs, for example, is the backtracking algorithm, which is often used to solve many problems. although there is nothing special about dfs and bfs in that they are essentially brute force methods of search, they are nonetheless powerful tools that can be used to tackle countless tasks. it's also just good exercise with python. i hope you've enjoyed reading this blog. catch you up in the next one.
i've been using a music streaming service for the past few weeks, and it's been a great experience so far. i usually listen to some smoothing new age piano or jazz while i'm working, while i prefer k pop on my daily commutes and bass heavy house music during my workouts. having processed these information through repeated user input on my part, the streaming application now regularly generates playlists each reflective of the three different genres of music that i enjoy most. this got me wondering: what is the underlying algorithm beind content selection and recommendation? how do prominent streaming services such as netflix and spotify provide recommendations to their users that seem to reflect their personal preferences and tastes? from a business perspective, these questions carry extreme significance since the accuracy of a recommendation algorithm may directly impact sales revenue. in this post, we will dive into this question by developing an elementary recommendation engine. the mechanism we will use to achieve this objective is a technique in linear algebra known as singular value decomposition or svd for short. svd is an incredibly powerful way of processing data, and also ties in with other important techniques in applied statistics such as principal component analysis, which we might also take a look at in a future post. enough with the preface, let's dive right into developing our model. before we start coding away, let's first try to understand what singular value decomposition is. in a previous post on markov chains, we examined the clockwork behind eigendecomposition, a technique used to decompose non degenerate square matrices. singular value decomposition is similar to eigendecomposition in that it is a technique that can be used to factor matrices into distinct components. in fact, in deriving the svd formula, we will later inevitably run into eigenvalues and eigenvectors, which should remind us of eigendecomposition. however, svd is distinct from eigendecomposition in that it can be used to factor not only square matrices, but any matrices, whether square or rectangular, degenerate or non singular. this wide applicability is what makes singular decomposition such a useful method of processing matrices. now that we have a general idea of what svd entails, let's get down into the details. in this section, we take a look at the mathematical clockwork behind the svd formula. in doing so, we might run into some concepts of linear algebra that requie us to understand some basic the properties of symmetric matrices. the first section is devoted to explaining the formula using these properties; the second section provides explanations and simple proofs for some of the properties that we reference duirng derivation. we might as well start by presenting the formula for singular value decomposition. given some by matrix , singular value decomposition can be performed as follows: there are two important points to be made about formula . the first pertains to the dimensions of each factor: , , . in eigendecomposition, the factors were all square matrices whose dimension was identical to that of the matrix that we sought to decompose. in svd, however, since the target matrix can be rectangular, the factors are always of the same shape. the second point to note is that and are orthogonal matrices; , a diagonal matrix. this decomposition structure is similar to that of eigendecomposition, and this is no coincidence: in fact, formula can simply be shown by performing an eigendecomposition on and . let's begin by calculating the first case, , assuming formiula . this process looks as follows: the last equality stands since the inverse of an orthogonal matrix is equal to its transpose. substituting for , equation simplifies to and we finally have what we have seen with eigendecomposition: a matrix of independent vectors equal to the rank of the original matrix, a diagonal matrix, and an inverse. indeed, what we have in is an eigendecomposition of the matrix . intuitively speaking, because matrix is not necessarily square, we calculate to make it square, then perform the familiar eigendecomposition. note that we have orthogonal eigenvectors in this case because is a symmetric matrix more specifically, positive semi definite. we won't get into this subtopic too much, but we will explore a very simple proof for this property, so don't worry. for now, let's continue with our exploration of the svd formula by turning our attention from matrix a factor of eigendecomposition on to the matrix . much like we understood as a factor of eigendecomposition, can be seen as a factor of eigendecomposition, this time on the matrix . concretly, notice the parallel between and . it's not difficult to see that, by symmetry, is also going to be an orthogonal matrix containing the eigenvectors of . the most important difference between and concerns dimensionality: while is a by matrix, v is an by . this disparity originates from the fact that itself is a rectangular matrix, meaning that the dimensions of and are also different. another point that requires clarification pertains to . earlier, we made a substitution of for . this tells us that contains the square roots of the eigenvalues of and , which, it is important to note, has identical non zero eigenvalues. if this point brings confusion, i recommend that you peruse over the next subsection on linear algebra. let's conclude this section with the formula for singular value decomposition: hopefully, now it is clear what , , and are. singular value decomposition can intuitively be thought of as a square root version of eigendecomposition, since essentially and are all derivatives that come from the "square" of a matrix, the two transpose multiples. this intuition also aligns with the fact that is a diagonal matrix containing the square roots of eigenvalues of the transpose products. with these in mind, let's get ready to build the recommendation model. in this optional section, we take a look at two mathematical propositions we referenced while motivating the svd formula: first, that symmetric matrices have orthogonal eigenvectors; second, that and have identical non zero eigenvalues. the proof for both of these statements are simple, but feel free to gloss over this section if you just want to see svd at work instead of the mathematical details behind singular value decomposition. let be some symmetric matrix, i.e. . also assume that has two distinct eigenvectors, and with corresponding eigenvalues and . with this setup, we start from the definition of eigenvectors and eigenvalues: if we apply transpose on both sides, we can legally multiply both sides by , which results in the following: however, since , furthermore, we can use the fact that the eigenvalue corresponding to is . then, since , the only way for to make sense is if and this is exactly what we have been trying to show. since and are two distinct eigenvectors of the symmetric matrix , we have successfully shown that any two eigenvectors of will be orthogonal, i.e. their dot product is going to be zero. let's start by assuming that has some non zero eigenvector whose corresponding eigenvalue is . then, we have if we left multiply both sides by , we get by the definition of an eigenvector, it is not difficult to see that has an eigenvector whose corresponding eigenvalue is . in short, the reason why svd works is that the eigenvalue matrix can be obtained either way by performing an eigendecomposition of the matrix or . now that we have a mathematical understanding of how singular value decomposition, let's see how we can apply svd to build a simple recommendation algorithm. this section will continue as follows. first, we examine svd as a technique of data compression and dimensionality reduction. next, we generate some toy data of movie reviews and apply svd to see how we can build a simple function that gives movie recommendations to users given their movie ratings history. let's jump right in. why is singular value decomposition so important? sure, it should now be fairly clear that svd is a decomposition technique that can be applied to any matrix, whether square or not, which in and of itself makes it a very powerful tool in the statistician's arsenal. but the true beauty of singular value decomposition comes from the fact that we can perform data compression by extracting meaningful information from the given data. this process is otherwise known as dimensionality reduction, and it is one of the most common applications of singular value decomposition. let's see what this means with an example. here is , a target matrix for singuluar value decomposition. calculating , we get which is symmetric as we expect. we can calculate the eigenvalues of this matrix by finding the roots of the following characteristic polynomial: since in svd is the diagonal matrix that contains the square roots of the eigenvalues of , we can conclude that where denotes the value of the th diagonal entry in . therefore, given the dimensionality of , we can conclude that next, we find the eigenvalues of . this process can be performed by identifying the null space of the matrix . for instance, given , given the orientation of this matrix, we see that by doing the same for , we can construct the matrix : repeating the procedure for to obtain the factor , we can complete the singular value decomposition on a: the key to dimensionality reduction is that the first few columns of , its corresponding eigenvalues in , and the corresponding first few rows of contain the most amount of information on matrix . as we go down the diagonal entries of , we see that the eigenvalues get smaller. the rule of thumb is that the smaller the eigenvalue, the lesser contribution it has on expressing data on . in other words, we can obtain an approximation of by extracting the first few columns and rows of each factor. for example, this may seem like a very clumsy way of approximating . however, this is because the toy matrix we dealt with was a mere two by three matrix with only two non zero entries in the diagonal of . imagine performing the same analysis on a much larger matrix, from which we extract number of non trivial entries of . on scale, singular value decomposition becomes more powerful, as it allows large amounts of data to be processed in managable bites. this is more than enough theory on svd. now is finally the time to jump into building our recommendation model with singular value decomposition. in this section, we will generate some random data, namely the ratings matrix. the row of the ratings matrix can be interpreted as users; the columns, movies. in other words, denotes the ratings the th user gave for the th movie. the example we will use was borrowed from this post by zacharia miller. let's quickly build this ratings matrix using and as shown below. let's first see what this matrix looks like. we can do this simply by calling the function and saving it to some variable. for notational consistency, let's name this variable . great! now we have a matrix of binary numbers, where denotes the fact that the user liked the movie and the fact that they disliked it. we can make some cursory qualitative observations of this toy data. note, for instance, that users who like movie 2 also tend to like movie 3. also, user 6 and user 8 have identical prefernece for movies perhaps they both like a particular genre, or tend to like the movie starred by some actor or actress. we would expect singular value decomposition to capture these observations in some way, albeit approximately. now, let's actually perform singular value decomposition on the ratings matrix. we could try to do this manually by hand, but let's utilize the power of modern computing to save ourselves of the time and mental effort involved in calculating the eigenvalues and eigenvectors of a ten by ten matrix. luckily for us, the module contains some excellent functionality to help us with singular value decomposition. using this library, singular value decomposition can very simply be achieved with just a few lines of code. the parameters of the function are , the ratings matrix, and , the number of non trivial entries of to select for dimensionality reduction, as we have seen earlier. more technically speaking, corresponds to the number of "concepts" or dimensions that we will extract from the matrix. let's see what this means by actually running this function. great! this is what dimensionality reduction means in the loosest sense. instead of having 5 entries each row, as we had with the original ratings matrix , we now have 3 entries per row. in other words, the information on users has been compressed into three dimensions. unlike in , where each column corresponded to some movie, we don't really know what the columns of stand for. it might be some genre, actress, or any hidden patterns in the data set that we are not aware of. regardless, what's important here is that we can now understand data more easily in smaller dimensions. an impotant observation to make is that, as we have noted earlier, user 6 and user 8 have rows that are identical. while this should not be a surprise given that the two users had what seemed to be an identical taste in movies, it is still interesting to see how svd is able to extract this information and display it onto a new axis. next, let's see what looks like. shown above is the transpose of , which means that is just really . what's important here is that the five movies have also been reduced to three dimensions. we don't really know what the columns of this matrix means; all we know is that it is some distillation and amalgamation of information about the ten users on some unknown axis. at any rate, the previous ten dimensional vectors have now been reduced to three dimensions, which is great news for us as three dimensional beings, it's always easier to visualize and deal with three dimensions or less than 10d. movie 2 and movie 3 do not look as similar as they did before on the ratings matrix. however, perhaps this is due to the fact that all entries of this matrix have pretty small values, and it is difficult to see how the difference between movie 2 and 3 compares to, say, the distance between movies 1 and 4. perhaps we should scale this in terms of relative distances or plot it on a three dimensional space, which is exactly what we are going to in a moment. before we jump into visualizations, however, let's deal with the elephant in the room first: is it okay to simply chop off a few dimensions to reduce a high dimensional image to fit into three dimensional space? to answer this question, let's check the matrix for this particular instance of singular value decomposition. array note that we already have the first three values of in our hands given that in our instantiation of singular value decomposition. the information we lose pertains to the last two values, given by and . these values are smaller in order of magnitude compared to, for instance, the largest value of , which is . this supports the idea that the information we lose amid dimensionality reduction is minimal. alternatively, we can also see this by taking a look at the full, unreduced version of the matrix or . for example, the code snippet below displays the full version of the factor . it is not difficult to see that the last few columns of contain values so small that their contribution to data is going to be minimal at best. this is not the most mathematical way of presenting the concept of data doing so would require us to take a look at other metrics such as covariance but this basic analysis will suffice for our purposes for now. the takeaway is that dimensionality reduction is a meaningful way to extract important information from our data. now that we have performed svd on the ratings matrix, let's move onto the last step: crafting a model for our recommendation algorithm. my personal pet theory is that using any word in conjunction with "algorithm" makes the concept sound more complex than it actually is. this is exactly what we are doing here, because in reality, our so called algoithm for movie recommendations is going to be very simple. the intuition behind the recommendation system is distance calculation. simply put, if users have similar movie preferences, the points representing the two users will appear to be close when plotted on a graph. let's see what this means by plotting using . this can be achieved with the following code. we can pass as an argument for the function to see a three dimensional plot of users' movie preferences, as shown below. note that the points corresponding to user 6 and user 8 exactly overlap, which is why the points look darker despite being positioned near the corner of the plot. this is also why we can only count seven points in total despite having plotted eight data points. in short, this visualization shows how we might be able to use distance calculation to give movie recommendations to a new user. assume, for instance, that we get a new suscriber to our movie application. if we can plot onto the space above, we will be able to see to whom user 10's preference is most similar. this comparison is useful since user 10 will most likely like the movie that the other use also rated highly. we can also create a similar plot for movies instead of users. the plot is shown below: with some alteration of the viewing angle, now we see through visualization that movies 2 and 3 are close, as we had expected from the original ratings matrix . this is an interesting result, and it shows just how powerful singular value decomposition is at extracting important patterns from given data sets. now that we understand what svd does for us, it's time to code our recommender function that uses distance calculation to output movie recommendations. in this post, we will be using the dot product as a means of determining distance, although other metrics such as euclidean distance would suit our purposes as well. an advantage of using the dot product is that it is computationally less expensive and easy to achieve with code, as shown below. the function recommends an number of movies given that the user rated highly. for example, let's say some user really liked movie 2 and is looking for two more movies that are similar to movie 2. then, we can simply call the function above by passing in appropriate arguments as follows. 3, 4 this function tells us that our movie application should recommend to our user movies 3 and 4, in that order. this result is not surprising given the fact that we have already observed the closeness between movies 2 and 3 if a user likes movie 2, we should definitely recommend movie 3 to them. our algorithm also tells us that the distance between movie 2 and 4 is also pretty close, although not as close as the distance between movies 2 and 3. what is happening behind the scene here? our function simply calculates the distance between the vector representation of each movies as a dot product. if we were to print the local variable array defined within the function, for instance, we would see the following result. 0, 0.21039350295933443, 1, 0.033077064237217, 3, 0.4411602025458312, 4, 0.07975391765448048 this tells us how close movies 0, 1, 3, and 4 are with movie 2. the larger the dot product, the closer the movie; hence, the more compelling that recommendation. the function then sorts the array and outputs the first movies as a recommendation. of course, we could think of an alternate implementation of this algorithm that makes use of the matrix instead of , but that would be a slightly different recommendation system that uses past user's movie ratings as information to predict whether or not the particular individual would like a given movie. as we can see, svd can be used in countless ways in the domain of recommendation algorithms, which goes to show how powerful it is as a tool for data analysis. in today's post, we dealt primarily with singular value decomposition and its application in the context of recommendation systems. although the system we built in this post is extremely simple, especially in comparison to the complex models that companies use in real life situations, nonetheless our exploration of svd is valuable in that we started from the bare basics to build our own model. what is even more fascinating is that many recommendation systems involve singular value decomposition in one way or another, meaning that our exploration is not detached from the context of reality. hopefully this post has given you some intuition behind how recommendation systems work and what math is involved in those algorithms. on a tangential note, recently, i have begun to realize that linear algebra as a university subject is very different from linear algebra as a field of applied math. although i found interest in linear algebra last year when i took the course as a first year, studying math on my own has endowed me with a more holistic understanding of how the concepts and formulas we learned in linear algebra class can be used in real life contexts. while i am no expert in pedagogy or teaching methodology, this makes me believe that perhaps linear algebra could be taught better if students were exposed to applications with appropriate data to toy around with. just a passing thought. anyhow, that's enough blogging for today. catch you up in the next one. singular value decomposition: https://en.wikipedia.org/wiki/singular_value_decomposition previous post: https://jaketae.github.io/study/markov chain/ eigendecomposition: https://en.wikipedia.org/wiki/eigendecomposition_of_a_matrix eigenvalues and eigenvectors: https://en.wikipedia.org/wiki/eigenvalues_and_eigenvectors this post: http://zwmiller.com/projects/simple_recommender.html
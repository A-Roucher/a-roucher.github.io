these past few days, i've been writing posts on r while reading hadley wickham's r for data science. r is no python, but i'm definitely starting to see what makes r such an attractive language for data analysis. in particular, writing texts and code blocks on rstudio has been a good experience so far, keeping me focused and productive in my quest to r mastery . however, this newfound interest of mine has created a bit of a turbulence in my blog workflow. previously, the vast majority of my work fell into one of two categories: a math oriented post that only required mathjax on markdown a code oriented post written on jupyter notebooks, mostly with python therefore, the automation workflow that i had set up using worked perfectly fine, since i could simply write a jupyter notebook, then convert it into markdown format and do make whatever minor modifications are necessary prior to publishing. however, this certainly did not work for r notebooks, or r markdown documents, which go by the extension . although and files are functionally somewhat similar in that they both allow people to write both texts and execute code blocks all in one document, they are distinct file formats, and hence the based workflow had to be modified. is a functionality in rstudio that allows people to export files into other file formats, such as html, pdf, or even markdown documents. obviously, given the current setup of my blog, which uses jekyll, i need to export the notebooks into markdown format. so this was great news. here is the setup i use for knitting my document. the part that matters most is the section of the yaml front matter. here, we specify that we want to export the r notebook as a , which stands for markdown document. i also realized that setting to saves me a bit of hassle since the , , and can be pre configured within the r notebook. with this yaml header, clicking on the green knit button will make rstudio do its thing and churn out a file, as well as an image folder that contains the plots and graphs created from executing the code blocks in the notebook. however, the knit button is certainly not a magic button. one problem with the knit function is that, by default, it creates a directory of image files in the same location where the notebook is located. in my case, this was the directory. in other words, knitting would result in the creation of a directory like . moreover, the knitted file would also be in the directory. however, this was not how i had organized my files. here is a heavily truncated summary of how the blog is currently organized. a lot of irrelevant directories containing other customizations were omitted in this summary. in case you're wondering how to create this summary, run here is the result i got with my blog directory. as you can see, the images are located in the directory. also, the notebooks and the posts are in separate locations: while the notebooks reside in , the posts live in . therefore, knitting would mean that i would have to move the knitted file to move the knitted images to fortunately, it's pretty easy to achieve these tasks using the linux shell. in fact, this is very similar to what we had done previously with jupyter notebooks: only this time, r notebooks were added into the mix. therefore, i had to update the existing shell script to account for both and file separately. being lazy programmers, we always want to automate things as much as possible. my end goal was to achieve all the knitting, converting, and moving in just a single line on the command prompt. the first thing i had to do was to update the python and shell scripts that i had previously for handling files. let's first take a look at the previous shell script i had, introduced in this post. what this script does is pretty simple: it uses to create a file from a file. then, it uses a python script to make some edits. lastly, we move the image and markdown files to appropriate locations. here is the script after the revamp, with added functionality to account for files as well. the function can be seen as the driver program that fires different functions depending on the extension of the input file, specified as an argument on the command line. the function is nearly identical to what we had before. the only change is that the function now performs a preliminary check of whether or not an image directory exists before attempting to move it. the addition lies in , which is a function that performs both the knitting, editing, and the moving. due to the anaconda based r setup i've described in this post, using the command in the terminal requires the activation of the relevant virtual environment. after some searching, i realized that this can be done with . after activating the environment, knitting is performed via . then, it's the same drill all over again: edit the file with a python script, then move the files to their respective locations in the blog directory. when all of this is done, we open the newly created markdown file in the directory using our favorite markdown editor, typora. the reason why we need a python script is that the image hyperlinks are most often broken, leading to rendering issues. this issue was documented in the previous post for the case with ; hence the regular expressions with find and replace you see in the function. knitting on r does not engender the same issue. in fact, it works without issues. the issue arises, however, when we move the image file directory to . when the directory is moved, the hyperlinks start to break down. therefore, we have to make some adjustments. this improved python script accounts for both cases of and files, much like the shell script is able to handle both cases. while going about this task, i ran into a number of issues. among them, the most important one was to configure the python script to be able to handle and based markdown files. if the knitted or converted file are both markdown files, how would the python script know which markdown file was created from a r markdown or a ipython notebook? i decided to resolve this by passing an additional argument to the python script; hence the , which is the or flag. but in the end, this flag is hidden to the user it is a hidden api and thus does not introduce additional complexities to the usability of the script. shell scripting turned out to be more interesting than i had thought. i'm satisfied because a lot of manual work is now the computer's job; as a writer, i can now focus only on publishing quality content without having to fiddle with files or minor formatting issues with hyperlinks to images. this works with both ipython and r notebooks, which was the end goal of this little endeavor. shell scripting is something i hope to continue doing. if there is one thing i learned, it is that python + shell is an incredibly powerful combination that never goes wrong.
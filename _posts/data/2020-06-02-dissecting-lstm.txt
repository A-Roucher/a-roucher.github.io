in this post, we will revisit the topic of recurrent neural networks, or rnns. although we have used rnns before in a previous post on character based text prediction, we glossed over lstm and assumed it as a black box that just worked. today, we will take a detailed look at how lstms work by dissecting its components. note that this post was inspired by this article by kristiadi. i also heavily referenced this post by christopher olah. if you find any part of this article intriguing and intellectually captivating, you will surely enjoy reading their blogs as well. with this in mind, let's jump right into it. long short term memory networks, or lstms for short, are one of the most widely used building blocks of recurrent neural networks, or rnns. this is because lstms overcame many of the limitations of basic vanilla rnns: while simple rnn gates are bad at retaining long term information and only remember input information that were fed into it relatively recently, lstms do a great job of retaining important information, even if they were fed into the cell long time ago. in other words, they are able to somewhat mimic the function of the brain, which involves both long and short term memory. the structure of an lstm cell might be summarized as follows: note that represents the hadamard product), which is nothing more than just the element wise multiplication of matrices. this long list of equations surely looks like a lot, but each of them has a specific purpose. let's take a look. the first component of lstm is the forget gate. this corresponds to these two set of equations: is nothing more than just the good old forward pass. we concatenate and , then multiply it with some weights, add a bias, and apply a sigmoid activation. at this point, you might be wondering why we use a sigmoid activation instead of something like relu. the reason behind this choice of activation function becomes apparent once we look at , which is how lstm imitates forgetting. for now, we will only focus on the first term in . recall that the output of a sigmoid activation is between 0 and 1. say the output of applying a sigmoid activation results in some value that is very close to 0. in that case, calculating the hadamard product will also result in a value of an entry very close to 0. given the interpretation that , also known as the cell state, is an artificial way of simulating long term memory, we can see how having zeros is similar to forgetfulness: a zero entry effectively means that the network deemed a particular piece of information as obsolete and decided to forget it in favor of accepting new information. in short, the sigmoid activation and the hadamard product form the basis of lstm's forget gate. by now, it should be apparent why we use sigmoid activations: instead of causing divergence with something like relu, we want to deliberately saturate and cause the network to produce some "vanishing" values. but if our lstm network only keeps forgetting, obviously this is going to be problematic. instead, we also want to update the cell state using the new input values. let's take a look at the cell state equation again: previously when discussing the forget gate, we focused only on the first term. taking a look at the second term, we note that the term is adding some value to the cell state that has been updated to forget information. it only makes sense, then, for the second term to perform the information update sequence. but to understand the second term, we need to take a look at two other equations: is another forward pass involving concatenation, much like we saw in with . the only difference is that, instead of forgetting, is meant to simulate an update of the cell state. in some lstm variants, is simply replaced with , in which case the cell state update would be rewritten as however, we will stick to the convention that uses instead of the simpler variant as shown in . the best way to think of or is a filter: is a filter that determines which information to be updated and passed onto the cell state. now all we need are the raw materials to pass into that filter. the raw material is , defined in . notice that we use a activation instead of a sigmoid, since the aim of is not to produce a filter with sparse entries, but rather to generate substance, or potential information to be stored in memory. this is more in line with the classic vanilla neural network architecture we are familiar with. now, we can finally glue the pieces together to understand : we enforce forgetfulness, then supply the cell state with new information. this is now the updated cell state, which gets passed onto the next sequence as new inputs are fed into the lstm. so far, we have only looked at the recurrent features of lstm; in other words, how it uses information from the past to update its knowledge in the present at time . however, we haven't yet discussed the most important part of any neural network: generating output. obviously, all that hassle of forgetting and updating the cell state would be utterly meaningless if the cell state is not used to generate output. the whole purpose of maintaining a cell state, therefore, is to imitate long and short term memory of the brain to generate some output. thus, it is no surprise that the following two equations are structured the way they are: first, we see the familiar forward pass, a familiar structure we have seen earlier. borrowing the analogy we established in the previous post, is a filter that decides which information to use and drop. the raw material that we pass into this filter is in fact the cell state, processed by a activation function. this is also a familiar structure we saw earlier in the information update sequence of the network. only this time, we use the cell state to generate output. this makes sense somewhat intuitively, since the cell state is essentially the memory of the network, and hence to generate output would require the use of this memory. of course, this should not be construed so literally since what ultimately happens during backpropagation is entirely up to the network, and at that point we simply lay back and hope for the network to learn the best. this point notwithstanding, i find this admittedly coarse heuristic to be nonetheless useful in intuiting the clockwork behind lstms. at this point, we're not quite done yet; is not a vector of probabilities indicating which letter is the most likely in a one hot encoded representation. therefore, we will need to pass it through another affine layer, than apply a softmax activation. hence, is the final output of an lstm layer. here comes the tricky part: backprop. thankfully, backprop is somewhat simple in the case of lstms due to the use of hadamard products. the routine is not so much different from a vanilla neural network, so let's try to hash out the equations. as we already know, backpropagation in neural networks is merely an extended application of the chain rule, with some minor caveats that matrix calculus entails. first, let's begin slow and easy by deriving the expressions for the derivative of the sigmoid and the functions. first, below is the derivative of the sigmoid with respect to , the input. recall that the sigmoid function is defined as . let's do the same for . one useful fact about is the fact that it is in fact nothing more than just a rescaled sigmoid. this relationship becomes a bit more apparent when we graph the two functions side by side. let's refer to the definition of to derive an expression for its derivative . we know that note that is denoted as in the code segment. since we have this information, now it's just a matter of back propagating the gradients to the lower segments of the acyclic graph that defines the neural network. given , it only makes sense to continue with the next parameter, . the transpose or the order in which the terms are multiplied may be confusing, but with just some scratch work on paper, it isn't difficult to verify these gradients by checking their dimensions. the equation for is even simpler, since there is no matrix multiplication involved. thus, the gradient flows backwards without any modification. moving down a layer, we come across : let's begin by trying to find the gradient for . you might be wondering what the term is doing in that equation. after all, isn't that quantity precisely what we are trying to calculate? this is the one tricky yet also interesting part about rnn backpropagation. recall that the whole point of a recurrent neural network is its use of variables from the previous forward pass. for example, we know that in the next forward pass, will be concatenated with the input . in the backpropagation step corresponding to that forward pass, we would have computed ; thus, this gradient flows into the current backpropagation as well. although this diagram applies to a standard rnn instead of an lstm, the recurrent nature of backprop still stands. i present it here because i find this diagram to be very intuitive. if you look at the right, the star represents the gradient from the last pass. if you look to the left, you will see that there is going to be a gradient for that will eventually be passed over to the next backpropgation scheme. since the forward pass is recurrent, so is the backward pass. since we have , now it's time to move further. let's derive the expression for the gradient for . let's do the same for the other term, . to make things easier, let's make a quick substitution with an intermediate variable, i.e. let . then, but was just an intermediate variable. how can we get the gradient for itself? well, since the only transformation was just a , chain rule tells us that all we need is to multiply the antiderivative of , which we already derived above. also keep in mind that since is a recurrent variable, we have to apply the gradient from the next call as well, just like . note that all we had to do is to multiply the function we derived above, then add the backpropgation from the next iteration to account for the recurrent nature of the network. we still have a decent amount of work to do, but the fortunate news is that once we derive an expression for one parameter, the rest can also be obtained in an identical fashion. therefore, for the sake of demonstration, we will only deal with and . let's start with the easier of the two, . recall that as we have done earlier, let's introduce an intermediate variable, , and try deriving the gradient for that variable. note that with this substitution, . now we can move onto deriving the expressions for the gradient of the actual parameters, starting with . this is extremely simple since and are defined by a linear relationship. the next in line is . this is also very simple, since all we need to do is to consider one instance of matrix multiplication. where, given a concatenation operator , now we are done! the gradient for the rest of the parameters, such as or look almost exactly the same as and respectively, and not without reason: as we have noted above, what i conveniently called the filter and raw material structure of lstm gates remain consistent across the forget, input, and output gates. therefore, we can apply the same chain rule to arrive at the same expressions. however, there is one more caveat that requires our last bit of attention, and that is the gradient for . note that had been concatenated to the input in the form of throughout the forward pass. because this was a variable that was used during computation, we need to calculate its gradient as well. this might appear rather confusing since we are currently looking at time , and it seems as if the gradient for variables should be happening in the next iteration of backpropagation. while this is certainly true for the most part, due to the recurrent nature of lstms, we need to compute these gradients for in this step as well. this is precisely what we were talking about earlier when discussing the recurrent nature of backprop; the we compute here will be used in the next iteration of backpropagation, just like we added in the current backprop to calculate . becaue was used in many different places during the forward pass, we need to collect the gradients. given an intermediate variable we can express the gradient in the following fashion: then, we can obtain by un concatenation: where denotes the number of neurons in the lstm layer. we can do the same for . this is a lot simpler: these gradients, of course, will be passed onto the next iteration of backpropagation, just like we had assumed that the values of and were given from the previous sequence of backpropagation. because dl libraries make it extremely easy to declare and train lstm networks, it's often easy to gloss over what actually happens under the hood. however, there is certainly merit to dissecting and trying to understand the inner working of dl models like lstm cells, which offer a fascinating way of understanding the notion of memory. this is also important since rnns are the basis of other more complicated models such as attention based models or transformers, which is arguably the hottest topic these days in the field of nlp with the introduction of gpt 3 by openai. i hope you have enjoyed reading this post. catch you up in the next one!
welcome back to another episode of "from scratch" series on this blog, where we explore various machine learning algorithms by hand coding them from scratch. so far , we have looked at various machine learning models, such as knn, logistic regression, and naive bayes. now is time for an exciting addition to this mix: neural networks. around last year december, i bought my first book on deep learning, titled deep learning from scratch, by saito goki. it was a korean translation of a book originally published in japanese by o'reilly japan. many bloggers recommended the book as the go to introductory textbook on deep learning, some even going as far as to say that it is a must have. after reading a few pages in, i could see why: as the title claimed, the author used only to essentially recreate deep learning models, ranging from simple vanilla neural networks to convolutional neural networks. as someone who had just started to learn python, following the book was a lot harder than expected, but it was a worthwhile read indeed. inspired by that book, and in part in an attempt to test the knowledge i gained from having read that bok, i decided to implement my own rendition of a simple neural network supported by minibatch gradient descent. let's jump right into it. the default setup of my jupyter notebook, as always: before we start building our model, we should first prepare some data. instead of using hand made dummy data as i had done in some previous posts, i decided to use the library to generate random data points. this approach makes a lot more sense given that neural networks require a lot more input data than do machine learning models. in this particular instance, we will use the function to accomplish this task. let's take a look at what our data looks like. array as expected, the dataset contains the and coordinates of the points generated by the function. if you haven't heard about this function before, you might be wondering what all the moons deal is about. well, if we plot the data points, it will become a lot more obvious. as you can see, the generated points belong to either one of two classes, and together, each class of points seem to form some sort of moon like shape. our goal will be to build a neural network that is capable of determining whether a given point belongs to class 0 or class 1. in other words, this is a classic example of a binary classification problem. it is standard practice in any classification problem to convert class labels into one hot encodeded vectors. the reason why this preprocessing is necessary is that the class number is merely a label that does not carry any meaning. assume a simple classification problem with 3 labels: 0, 1, and 2. in that context, a class label of 2 is not at all related to adding two data points belonging to class 1, or any arithmatic operation of that kind. to prevent our model from making such arbitrary, unhelpful connections, we convert class labels to one hot encoded vectors. we could use external libraries such as to invoke the function, but instead let's just build a function ourselves since this is a relatively simple task. let's test the function on the training data. we don't need the entire data to see that it works, so let's slice the array to see its first five elements. array when we apply to the data, we see that the returned result is a two dimensional array containing one hot encoded vectors, as intended. array that's all the data and the preprocessing we will need for now. activation functions are important aspects of neural networks. in fact, it is what allows neural networks to model nonlinearities in data. as we will see in the next section, a neural network is essentially composed of layers and weights that can be expressed as matrix multiplications. no matter how complex a matrix may be, matrix multiplication is a linear operation, which means that is impossible to model nonlinearities. this is where activation functions kick in: by applying nonlinear transformation to layer outputs, we can make neural networks capable of modeling nonlinearities. this is why deep learning is such a powerful tool: it can be trained to detect nonlinear, complex patterns in data that a human might otherwise be unable to identify. our vanilla neural network will make use of two activation functions: softmax and relu. if you have read my previous post on the keras functional api, you might recall that we used softmax and relu for certain dense layers. back then, we considered them to be a blackbox without necessarily taking a look at what they do. let's explore the details and get our hands dirty today. mathematically speaking, the softmax function is a function that takes a vector as input and outputs a vector of equal length. concretely, where although the formula may appear complex, the softmax function is a lot simpler than it seems. first, note that all entries of the returned vector add up to 1. from here, it is possible to see that the softmax function is useful for ascribing the probability that a sample belongs to one of classes: the th element of would indicate the probability of the sample belonging to the th class. put another way, the index of the largest entry in is the class label number that is most probable. implementing the softmax function is extremely easy thanks to the vectorized computation made possible through . presented below is one possible implementation of the softmax function in python. this particular implementation, however, poses two problems. first, it is susceptible to arithematic overflow. because computing the softmax function require exponentiation, it is likely for the computer to end up with very large numerical quantities, making calculations unstable. one way to solve this problem is by subtracting values from the exponent. as the calculation shows, adding or subtracting the same value from the exponent of both the numerator and the denominator creates no difference for the output of the softmax function. therefore, we can prevent numbers from getting too large by subtracting some value from the exponent, thus yielding accurate results from stable computation. we can further improve the softmax function for the purposes of this tutorial by supporting batch computation. by batch, i simply mean multiple inputs in the form of arrays. the function shown above is only able to account for a single vector, presumably given as a list or a one dimensional numpy array. the implementation below uses a loop to calculate the softmax output of each instance in a matrix input, then returns the result. note that it also prevents arithematic overflow by subtracting the value of the input array. let's test the improved softmax function with a two dimensional array containing two instances. array as expected, the softmax function returns the softmax output applied to each individual instance in the list. note that the elements of each output instance add up to one, as expected. another crucial activation function is relu), or the rectified linear unit. relu is a piece wise function, and hence introduces nonlinearity, which is one of the purposes of having an activation function in a neural network. the formula for relu is extremely simple. if the input value i s greater or equal to zero, the relu function outputs the value without modification. however, if is smaller than zero, the returned value is also zero. there are other ways of expressing the relu function. one version that is commonly used and thus deserves our attention is written below. although this appears different from , both formulas express the same operation at their core. we can get a better sense of what the function with the help of python. assuming that the input is a vector, we can use vectorization to change only the elements in the input vector that are negative to zero, as shown below. let's see what the relu function looks like by plotting it on the plane. the visualization makes clear the point that relu is a piece wise function that flattens out negative values while leaving positive values unchanged. now that we have all the ingredients ready, it's time to build the neural network. earlier, i said that a neural network can be reduced to matrix multiplication. this is obviously an oversimplification, but there is a degree of truth to that statement. recall that a single neuron of a neural network can be expressed as a dot product of two vectors, as shown below. following conventional notation, represents weights; , input data; , bias. visually, we can imagine the neuron being lit up when the value is large. this is similar to how the human brain works, except that biological neurons are binary in that they either fires on or off; artifical neurons in a network typically take a range of values. if we expand the vector operation in , it becomes quickly obvious that we can represent an entire layer of neurons as a product of two matrices. our simple neural network model can thus be expressed as follows: the equations above represent our simple neural network model composed of two affine layers. the output of the first affine layer, , is modified by a relu unit. then, the output is passed onto the second affine layer, , the output of which is passed onto a softmax unit. the output of the softmax function is the final output of our model. note that relu and softmax are denoted as max and sigma, respectively. the code below is a function that intializes our network. because our data only has two classes, with each data point containing two entries corresponding to the and coordinates of that point, we set both and arguments to 2 by default. the number of neurons in the affine layers, denoted as , is arbitrarily set to 64. the returns a dictionary that contains all the weights of the model. note that we need to pay close attention to the dimensionality of our data to ensure that matrix multiplication is possible. we don't have to worry about the dimensionality of the bias since supports broadcasting by default. presented below is a visualization of our neural network, created using nn svg. instead of cluttering the diagram by attempting to visualize all 64 neurons, i decided to simplify the picture by assuming that we have 16 neurons in each of the affine layers. but with the power of imagination, i'm sure it's not so much difficult to see how the picture would change with 64 neurons. hopefully the visualization gave you a better understanding of what our model looks like. now that we have a function that creates our model, we are ready to run the model! at this point, our neural network model is only a dictionary that contains matrices of specified sizes, each containing randomly genereated numbers. you might be wondering how a dictionary can be considered a model after all, a dictionary is merely a data structure, and so is incapable of performing any operations. to make our model to work, therefore, we need a function that performs matrix multiplications and applies activation functions based on the dictionary. the function is precisely such a function that uses the weights stored in our model to return both the intermediary and final outputs, denoted as and respectively. note that we apply activation functions, such as and when appropriate. this process of deriving an output from an input using a neural network is known as forward propagation. forward propagation is great and all, but without appropriately trained weights, our model is obviously going to spit out meaningless predictions. the way to go about this is to use the gradient descent algorithm with back propagation. we will discuss more about back propagation in the next subsection, as it is a meaty topic that deserves space of its own. we deal primarily with the former in this section. where represents the parameters, or weights, represents the learning rate, and represents the loss function. this is the vanilla gradient descent algorithm, which is also referred to as batch gradient descent. minibatch gradient descent is similar to gradient descent. the only point of difference is that it calculates the gradient for each minibatch instead of doing so for the entire dataset as does batch gradient descent. the advantage of using a minibatch is that it is computationally lighter and less expensive. minibatch gradient descent can be considered a happy point of compromise between stochastic and batch gradient descent, which lie on the polar opposite ends of the spectrum. let's first take a look at the function, which divides the and into and given a . internally, the function calls the gradient descent algorithm to update the weights and finally returns the which contains updated parameters based on the training data. as mentioned above, each and are minibatches that will be feeded into our gradient descent function. note that the function is simply an implementation of equation . at the core of the function is the function, which is our implementation of back propagation. this provides a nice point of transition to the next section. back propagation is a smart way of calculating gradients. there are obviously many ways one might go about gradient calculation. we can simply imagine there being a loss function that is a function of all the thousands of weights and biases making up our neural network, and calculate partial derivatives for each parameter. however, this naive aproach is problematic because it is so computationally expensive. moreover, if you think about it for a second, you might realize that doing so would result in duplicate computations due to the chain rule. take the simple example below. if we were to calculate the gradient of the loss function with respect to and , all we need to compute is the gradient of , since that of will naturally be obtained along the way. in other words, computing the gradient simply requires that we start from the very end of the neural network and propagate the gradient values backwards to compute the partial derivatives according to the chain rule. this is what is at the heart of back propagation: in one huge swoop, we can obtain the gradient for all weights and parameters at once instead of having to calculate them individually. for a more detailed explanation of this mechanism, i strongly recommend that you take a look at this excellent blog post written by christopher olah. how do we go about back propagation in the case of our model? first, it is necessary to define a loss function. the most commonly used loss function in the context of classification problems is cross entropy, which we explored in this post previously on this blog. for a brief recap, presented below is the formula for calculating cross entropy given a true distribution and a predicted distribution : our goal is to train our neural network so that is output distribution is as close to as possible. in the case of binary classification, we might alter equation to the following form: the reformulation as shown in equation is the formula for what is known as binary cross entropy. this is the equation that we will be using in the context of our problem, since the dataset we have only contains two class labels of 0 and 1. now that we have an idea of what the loss function looks like, it's time to calculate the gradient. since we are going to be back propagating the gradient, it makes sense to start from the very back of the neural network. recall that our neural network is structured as follows: the last layer is a softmax unit that receives input to produce output . our goal, then, is to compute the gradient where and each represent the values taken by the th and th neuron in layers and , respectively. one point of caution is that it is important to consider whether and are equal, as this produces differences in the calculation of the gradient. first consider the case when : when : we see that the gradient is different in the two cases! this is certainly going to important for us when calculating the gradient of , the cross entropy loss function, with respect to . specifically, we have to consider the two cases separately by dividing up the summation expression into two parts, as shown below: that was a long ride, but in the end, we end up with a very nice expression! this tells us that the gradient of the cross entropy loss function with respect to the second affine layer is simply the size of the error term. in other words, if we expand the result in to apply to the entire matrix of layers, we get this provides a great place for us to start. we can commence from here to find the gradient of the loss function with respect to other layers more further down the neural network. for example, we can calculate the gradient with respect to the weights of the second affine layer as follows: we won't get into much mathematical details here, but a useful intuition we can use to derive equation is to pay close attention to the dimensionality of data. note that the dimension of the gradient as a matrix should equal to that of the layer itself. in other words, , so on and so forth. this is because the purpose of gradient computation is to update the matrix of parameters: to perform an element by element update with the gradient, it must necessarily be true that the dimensionality of the gradient equals that of the original matrix. using this observation, it is possible to navigate through the confusion of transposes and left, right matrix multiplication that one might otherwise encounter if they were to approach it without any intuition or heuristics. to expedite this post, i'll present the result of the gradient calculations for all parameters below. note that the indicator function, denoted as , is a simple gate function that calculates the gradient of the relu unit: it isn't difficult to see that the indicator function is simply a derivative of the relu function as shown in equation . now, it is time to translate our findings into python. because our neural network model is represented as a dictionary, i decided to adopt the same data structure for the gradient. indeed, that is how we designed the function above. the function below is an implementation of back propagation that encapsulates equations through . there is a subtlety that i did not discuss previously, which has to do with the bias terms. it may appear as if the gradient of the bias term does not match that of the bias term itself. indeed, that is a valid observation according to equation . the way we go about this is that we add up the elements of the matrix according to columns. this is exactly what we do with the command invoked when computing and , which represent the gradient of the bias terms. with all the complex math behind, here is the code implementation of back propagation. finally, our model is ready to be trained! here is a simple function which we can use to train and test our model. because each iteration can yield a different accuracy, we repeat the experiment multiple times or specifically, times to obtain the mean accuracy of our model. we also get a standard deviation of the mean accuracy estimate to see whether or not the performance of the model is reliable and consistent. let's test our model with the and data, with batch size set to 10. mean accuracy: 0.94541, standard deviation: 0.019558 the mean accuracy of our model is around 95 percent, which isn't bad for a simple neural network with just two layers. the standard deviation is also reasonably low, indicating that the performance of our model is consistent with little variations. i was almost about to stop here, but then decided that i wanted to express the neural network model as a python class. after all, that is how actual machine learning and deep learning libraries are implemented. i also decided that it can't hurt for me to practice object oriented thinking. so presented in the next section is a nicer, cleaner implementation of a neural network model based off of the functions we designed above. a simple neural network model in just 56 lines of code, ready to be initialized, trained, deployed, and tested! you will see that much of the code is literally just copy and pasted from the original functions we designed above. but just to make sure that everything works fine, let's try creating a neural network object and use the function to see how well our model performs. i chose 99 as the number of neurons in the affine layers for no reason. 0.9496 in this instance, the accuracy of this model is 95 percent, similar to what we had above. at this point, one question that popped up in my mind was the relationship between the number of neurons and the performance of the neural network model. intuitively, the more neurons there are, the higher the memory capacity of that model, and thus better the performance. of course, the larger the number of neurons, the larger the risk of overfitting our model, which can also negatively impact the performance of the neural network. this is conventional wisdom in the land of deep learning. let's create a function to plot the performance of a neural network and the number of its neurons. below is a function that achieves this task. the function receives , , and as arguments. the first two arguments specify the range for the number of neurons that we are interested in. for example, if we set them to 3 and 40, respectively, that means we want to see the accuracy of models with number of neurons ranging from 3 to 40 in a single layer. the argument specifies the number of experiments we want to conduct. this way, we can calculate the mean accuracy, just as we did previously. let's call the function to create a plot. the result shows that the performance of the neural network generally increases as the number of neurons increase. we don't see signs of overfitting, but we know it happens: recall that our neural network model with 99 and 64 hidden neurons hit an accuracy of about 95 percent, whereas the model with only 30 to 40 neurons seem to be outperforming this metric by an accuracy hovering around 98 percent. after having realized this, i considered re running the function with a different range, but eventuially decided to stop the experiment because running the function took a lot more time than i had expected, even on google colab. creating and training the model takes a long time, especially if we are repeating this process times. for now, the simple observation that the performance seems to increase with more neurons, then fall at one point once overfitting starts to happen, will suffice to satisfy our curiosity. in this post, we built a neural network only using and math. this was a lot more difficult than building other machine learning models from scratch particularly because of the heavy mathematics involved. however, it was definitely worth the challenge becasue completing and writing up this tutorial made me think a lot more about the clockwork of a neural network model. it is easy to think of neural networks as a black box, especially given the sheer ease of creating it. with just , one can build a simple neural network like this one in no time. indeed, the main reason why i love the keras functional api so much is that it is so easy to code and deploy a neural network model. however, when we write such models by depending on preexisting libraries, we sometimes grow oblivious to the intricacies the take place under the hood. it is my hope that reading and following along this post gave you a renewed sense of respect for the writers of such libraries, as well as the beauty of neural network models themselves. i hope you enjoyed reading this post. catch you up in the next one!